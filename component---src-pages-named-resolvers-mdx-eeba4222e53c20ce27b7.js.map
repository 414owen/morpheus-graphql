{"version":3,"sources":["webpack:///./src/pages/named-resolvers.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","title","keywords","parentName","isMDXComponent"],"mappings":"qRAWaA,EAAe,GACtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,iBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAK5E,YAAC,IAAD,CAAKC,MAAM,kBAAkBC,SAAU,CAAC,mBAAoB,UAAW,WAAYF,QAAQ,QAC3F,mCACA,iFACA,sBACE,kBAAIG,WAAW,MAAK,sBAAQA,WAAW,MAAnB,uBAApB,qHAEA,kBAAIA,WAAW,MAAK,sBAAQA,WAAW,MAAnB,mBAApB,6CAAsH,0BAAYA,WAAW,MAAvB,gBAAtH,iHAIF,yCACA,0EAAyD,sBAAQA,WAAW,MAAnB,WACzD,sEAAqD,0BAAYA,WAAW,KAAvB,gBAArD,8cAQA,uNAIA,sCACA,qCACE,SAAY,UACZ,SAAY,SACZ,MAAS,WACT,eAAgB,QAJlB,eAMQ,oBAAMA,WAAW,wBACrB,KAAQ,QADJ,6PANR,cAyBA,8GACiB,0BAAYA,WAAW,KAAvB,QADjB,2DAC6H,0BAAYA,WAAW,KAAvB,MAD7H,sCAE+B,0BAAYA,WAAW,KAAvB,QAF/B,oBAEoG,0BAAYA,WAAW,KAAvB,SAFpG,6BAEmL,0BAAYA,WAAW,KAAvB,MAFnL,KAGA,qCACE,SAAY,UACZ,SAAY,SACZ,MAAS,WACT,eAAgB,QAJlB,eAMQ,oBAAMA,WAAW,wBACrB,KAAQ,QADJ,0NANR,cAgBA,oKAEA,uCAAsB,0BAAYA,WAAW,KAAvB,QAAtB,QAA+E,0BAAYA,WAAW,KAAvB,SAA/E,yHAEY,0BAAYA,WAAW,KAAvB,QAFZ,0BAEuF,0BAAYA,WAAW,KAAvB,gBAFvF,0BAGmB,0BAAYA,WAAW,KAAvB,QAHnB,oBAIA,qCACE,SAAY,UACZ,SAAY,SACZ,MAAS,WACT,eAAgB,QAJlB,eAMQ,oBAAMA,WAAW,wBACrB,KAAQ,QADJ,4QANR,cAiBA,qGACY,0BAAYA,WAAW,KAAvB,kBADZ,mCAEF,0BAAYA,WAAW,KAAvB,kBAFE,wBAGA,qCACE,SAAY,UACZ,SAAY,SACZ,MAAS,WACT,eAAgB,QAJlB,eAMQ,oBAAMA,WAAW,wBACrB,KAAQ,QADJ,0HANR,cAaA,wDAAuC,0BAAYA,WAAW,KAAvB,aAAvC,+DACe,0BAAYA,WAAW,KAAvB,iBADf,oDAEA,0BAAYA,WAAW,KAAvB,gBAFA,eAEwE,0BAAYA,WAAW,KAAvB,kDAFxE,8DAIA,+CAA8B,0BAAYA,WAAW,KAAvB,gBAA9B,2KAG4C,0BAAYA,WAAW,KAAvB,kBAH5C,oEAKA,wCACA,qCACE,SAAY,UACZ,SAAY,SACZ,MAAS,WACT,eAAgB,QAJlB,eAMQ,oBAAMA,WAAW,wBACrB,KAAQ,QADJ,4uCANR,cAwDA,qBAAG,kBAAIA,WAAW,KAAf,WACH,qCACE,SAAY,UACZ,SAAY,SACZ,MAAS,WACT,eAAgB,QAJlB,eAMQ,oBAAMA,WAAW,wBACrB,KAAQ,QADJ,kDANR,cAWA,uCAAsB,0BAAYA,WAAW,KAAvB,QAAtB,0CAAiH,0BAAYA,WAAW,KAAvB,MAAjH,8DAEF,0BAAYA,WAAW,KAAvB,QAFE,oCAEmF,0BAAYA,WAAW,KAAvB,UAFnF,MAOJN,EAAWO,gBAAiB","file":"component---src-pages-named-resolvers-mdx-eeba4222e53c20ce27b7.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/morpheus-graphql/morpheus-graphql/docs/src/components/layout.js\";\nimport { Link } from \"gatsby\";\nimport Layout from \"../components/layout\";\nimport SEO from \"../components/seo\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n\n    <SEO title=\"Named Resolvers\" keywords={[\"Morpheus GraphQL\", \"GraphQL\", \"Haskell\"]} mdxType=\"SEO\" />\n    <h1>{`Resolving`}</h1>\n    <p>{`Morpheus GraphQL provides two way of the type resolving.`}</p>\n    <ol>\n      <li parentName=\"ol\"><strong parentName=\"li\">{`Values as resolvers`}</strong>{`: In this approach, you just specify values\nfor the type definitions, where the resolvers are regular functions.`}</li>\n      <li parentName=\"ol\"><strong parentName=\"li\">{`Named resolvers`}</strong>{`: In this approach, we use the type class `}<inlineCode parentName=\"li\">{`ResolveNamed`}</inlineCode>{` to define the\nresolver for each type. More information on this approach can be\nfound in the next section.`}</li>\n    </ol>\n    <h2>{`Named Resolvers`}</h2>\n    <h6>{`Note: this feature will be introduced in version `}<strong parentName=\"h6\">{`0.18.0`}</strong></h6>\n    <p>{`As mentioned earlier, in this approach we use `}<inlineCode parentName=\"p\">{`ResolveNamed`}</inlineCode>{`\nto define the resolver function for each type. In this resolver definition,\neach type also defines its dependency (identifier), which is used by the\ncompiler to provide a corresponding output resolution for certain input values.\nThat is, if we want to resolve a type as a field of another type, we must\nspecify a type dependency value for that particular type\ninstead of the type value. For a better illustration,\nlet's look at the following example:`}</p>\n    <p>{`Let's say we want to create a GraphQL app for\na blogging website where we can either retrieve\nall posts or retrieve them by ID. Scheme definition for this\napplication would be as follows.`}</p>\n    <h3>{`App/Posts.hs`}</h3>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`newtype Post m = Post\n  { title :: m Text\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )\n\ndata Query m = Query\n  { posts :: m [Post m],\n    post :: Arg \"id\" ID -> m (Maybe (Post m))\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`Now that we have type definitions, we can define their resolvers,\nstarting with type `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{`. The following instance specifies that for each unique `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{`\nwe can resolve the corresponding `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{`, where the post `}<inlineCode parentName=\"p\">{`title`}</inlineCode>{` is retrieved by the post `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`instance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { title = resolve (getPostTitleById uid)\n        }`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`Let's go to the next stage and define query resolver. Since the query does not\nrequire an ID, we define its dependency with the unit type.`}</p>\n    <p>{`To resolve the `}<inlineCode parentName=\"p\">{`post`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`posts`}</inlineCode>{` fields, we only get post-ids and\npass them to the resolve function, which automatically resolves the\ncorresponding `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` values by calling the `}<inlineCode parentName=\"p\">{`ResolveNamed`}</inlineCode>{`\ninstance of the type `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` with those ids.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`instance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { posts = resolve getPostIds,\n          post = \\\\(Arg arg) -> resolve (pure (Just arg))\n        }`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`In the last step, we can derive the GraphQL application using\nthe data type `}<inlineCode parentName=\"p\">{`NamedResolvers`}</inlineCode>{` by using a single constructor\n`}<inlineCode parentName=\"p\">{`NamedResolvers`}</inlineCode>{` without any fields.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`postsApp :: App () IO\npostsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`in the background, the function `}<inlineCode parentName=\"p\">{`deriveApp`}</inlineCode>{` traverses the data types and calls their\nown instances of `}<inlineCode parentName=\"p\">{`NamedResolver`}</inlineCode>{` for each object and union type. In this way,\na `}<inlineCode parentName=\"p\">{`ResolverMaps`}</inlineCode>{` (with type `}<inlineCode parentName=\"p\">{`Map TypeName (DependencyValue -> ResolveValue)`}</inlineCode>{`) is derived that can\nbe used in GraphQL query execution.`}</p>\n    <p>{`As you can notice, the `}<inlineCode parentName=\"p\">{`ResolverMaps`}</inlineCode>{` derived in this way can be\nmerged if the types with the same name have the same GraphQL\nkind and the same dependency.\nTherefore, types in applications derived with `}<inlineCode parentName=\"p\">{`NamedResolvers`}</inlineCode>{` can be safely extended,\nwhich we will see in the next section.`}</p>\n    <h3>{`App/Authors.hs`}</h3>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Author m = Author\n  { name :: m Text,\n    posts :: m [Post m]\n  } deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Author (NamedResolverT m)) where\n  type Dep (Author (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Author\n        { name = resolve (getAuthorName uid),\n          posts = resolve (getAuthorPosts uid)\n        }\n\n-- is alternative to extend type\nnewtype Post m = Post\n  { author :: m (Author m)\n  } deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { author = resolve (pure uid)\n        }\n\n-- QUERY\ndata Query m = Query\n  { authors :: m [Author m],\n    authorById :: Arg \"id\" ID -> m (Maybe (Author m))\n  }\n  deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { authors = resolve getAuthorIds,\n          authorById = \\\\(Arg uid) -> resolve (pure (Just uid))\n        }\n\nauthorsApp :: App () IO\nauthorsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)`}</code>{`\n        `}</deckgo-highlight-code>\n    <p><em parentName=\"p\">{`App.hs`}</em></p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`app :: App () IO\napp = authorsApp <> postsApp`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`since the both `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` type definitions have same dependency `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{`,\nthe interpreter safelly merge this two apps where type\n`}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` will be extended with new field `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}