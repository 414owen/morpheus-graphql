{"version":3,"sources":["webpack:///./src/pages/server.mdx","webpack:///./src/components/section.js"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","title","keywords","id","parentName","level","isMDXComponent","style","color","textDecoration","padding","Section","children","setItem","useContext","NavContext"],"mappings":"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","file":"component---src-pages-server-mdx-314b929c1d97f56f76f7.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/morpheus-graphql/morpheus-graphql/docs/src/components/layout.js\";\nimport SEO from \"../components/seo\";\nimport { Section } from \"../components/section\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <SEO title=\"Type System\" keywords={[\"Morpheus GraphQL\", \"GraphQL\", \"Haskell\", \"Type System\"]} mdxType=\"SEO\" />\n    <h1>{`Server`}</h1>\n    <Section id=\"type-system\" mdxType=\"Section\">Type System</Section>\n    <p>{`Morpheus GraphQL covers all GraphQL data types with an equivalent\nHaskell representation. A prerequisite for these representation types is that\nthey must be derived by `}<inlineCode parentName=\"p\">{`Generic`}</inlineCode>{` and provide corresponding `}<inlineCode parentName=\"p\">{`GQLType`}</inlineCode>{` instances.`}</p>\n    <Section id=\"objects\" level={2} mdxType=\"Section\">\n  Object types\n    </Section>\n    <p>{`Object types are represented in Morpheus with Haskell records,\nwhere the parameter `}<inlineCode parentName=\"p\">{`m`}</inlineCode>{` passes the resolution monad\nto the field resolution functions. The following code snippet, for example,\ndefines the type Deity with a nullable field `}<inlineCode parentName=\"p\">{`power`}</inlineCode>{` and a non-nullable field `}<inlineCode parentName=\"p\">{`name`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Deity m = Deity\n  { name :: m Text         -- Non-Nullable Field\n  , power :: m Maybe Text   -- Nullable Field\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"arguments\" level={3} mdxType=\"Section\">\n  Arguments\n    </Section>\n    <p>{`GraphQL arguments can be represented with two ways:`}</p>\n    <h4>{`Haskell records`}</h4>\n    <p>{`we can use Haskell records to declare GraphQL arguments,\nwhere each field of a record represents a particular\nargument, and can be accessed by name.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Query m = Query\n  { deity :: DeityArgs -> m Deity\n  } deriving\n    ( Generic\n    , GQLType\n    )\n\ndata DeityArgs = DeityArgs\n  { name      :: Text        -- Required Argument\n  , mythology :: Maybe Text  -- Optional Argument\n  } deriving\n     ( Generic,\n       GQLType\n     )`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`This approach is quite convenient for representing multiple arguments,\nbut cumbersome if we only need one argument for each field.\nThat is why we also introduce \"Tagged Arguments\".`}</p>\n    <h4>{`Tagged function arguments`}</h4>\n    <p>{`Tagged arguments leverage type-level literals and enable GraphQL\narguments to be represented as a chain of named function arguments.\ne.g. the following type defines GraphQL field `}<inlineCode parentName=\"p\">{`deity`}</inlineCode>{` with the\noptional argument `}<inlineCode parentName=\"p\">{`name`}</inlineCode>{` of type `}<inlineCode parentName=\"p\">{`String`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Query m = Query\n  { deity :: Arg \"name\" (Maybe Text) -> m Deity\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"query\" level={3} mdxType=\"Section\">\n  Query\n    </Section>\n    <p>{`the GraphQL query type is represented in Morpheus GraphQL as a regular object type named `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Query m = Query\n  { deity ::  m Deity\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"mutations\" level={3} mdxType=\"Section\">\n  Mutations\n    </Section>\n    <p>{`In addition to queries, Morpheus also supports mutations. They behave just like regular queries and are defined similarly:`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`newtype Mutation m = Mutation\n  { createDeity :: MutArgs -> m Deity\n  } deriving (Generic, GQLType)\n\nrootResolver :: RootResolver IO  () Query Mutation Undefined\nrootResolver =\n  RootResolver\n    { queryResolver = Query {...}\n    , mutationResolver = Mutation { createDeity }\n    , subscriptionResolver = Undefined\n    }\n    where\n      -- Mutation Without Event Triggering\n      createDeity :: MutArgs -> ResolverM () IO Deity\n      createDeity_args = lift setDBAddress\n\ngqlApi :: ByteString -> IO ByteString\ngqlApi = interpreter rootResolver`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"subscription\" level={3} mdxType=\"Section\">\n  Subscriptions\n    </Section>\n    <p>{`In morpheus subscription and mutation communicate with Events,\n`}<inlineCode parentName=\"p\">{`Event`}</inlineCode>{` consists with user defined `}<inlineCode parentName=\"p\">{`Channel`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Content`}</inlineCode>{`.`}</p>\n    <p>{`Every subscription has its own Channel by which it will be triggered`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Channel\n  = ChannelA\n  | ChannelB\n\ndata Content\n  = ContentA Int\n  | ContentB Text\n\ntype MyEvent = Event Channel Content\n\nnewtype Query m = Query\n  { deity :: m Deity\n  } deriving (Generic)\n\nnewtype Mutation m = Mutation\n  { createDeity :: m Deity\n  } deriving (Generic)\n\nnewtype Subscription (m ::  * -> * ) = Subscription\n  { newDeity :: m  Deity\n  } deriving (Generic)\n\nnewtype Subscription (m :: * -> *) = Subscription\n{ newDeity :: SubscriptionField (m Deity),\n}\nderiving (Generic)\n\n\ntype APIEvent = Event Channel Content\n\nrootResolver :: RootResolver IO APIEvent Query Mutation Subscription\nrootResolver = RootResolver\n  { queryResolver        = Query { deity = fetchDeity }\n  , mutationResolver     = Mutation { createDeity }\n  , subscriptionResolver = Subscription { newDeity }\n  }\n where\n  -- Mutation Without Event Triggering\n  createDeity :: ResolverM EVENT IO Address\n  createDeity = do\n      requireAuthorized\n      publish [Event { channels = [ChannelA], content = ContentA 1 }]\n      lift dbCreateDeity\n  newDeity :: SubscriptionField (ResolverS EVENT IO Deity)\n  newDeity = subscribe ChannelA $ do\n    -- executed only once\n    -- immediate response on failures\n    requireAuthorized\n    pure $ \\\\(Event _ content) -> do\n        -- executes on every event\n        lift (getDBAddress content)`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"scalars\" level={2} mdxType=\"Section\">\n  Scalar types\n    </Section>\n    <p>{`any Haskell data type can be represented as a GraphQL scalar type.\nIn order to do this, the type must be associated as\n`}<inlineCode parentName=\"p\">{`SCALAR`}</inlineCode>{` and implemented with `}<inlineCode parentName=\"p\">{`DecodeScalar`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`EncodeScalar`}</inlineCode>{` instances.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Odd = Odd Int  deriving (Generic)\n\ninstance DecodeScalar Euro where\n  decodeScalar (Int x) = pure $ Odd (... )\n  decodeScalar _ = Left \"invalid Value!\"\n\ninstance EncodeScalar Euro where\n  encodeScalar (Odd value) = Int value\n\ninstance GQLType Odd where\n  type KIND Odd = SCALAR`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"enums\" level={2} mdxType=\"Section\">\n  Enumeration types\n    </Section>\n    <p>{`Data types where all constructors are empty are derived as GraphQL enums.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data City\n  = Athens\n  | Sparta\n  | Corinth\n  | Delphi\n  | Argos\n  deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"wrappers\" level={2} mdxType=\"Section\">\n  Lists and Non-Null\n    </Section>\n    <p>{`GraphQL Lists are represented with Haskell Lists.\nHowever, since in Haskell each type is intrinsically not nullable,\nnullable GraphQL fields are represented with `}<inlineCode parentName=\"p\">{`Maybe`}</inlineCode>{` Haskell data type and non-nullable\nGraphQL fields with regular Haskell datatypes.`}</p>\n    <Section id=\"interfaces\" level={2} mdxType=\"Section\">\n  Interfaces\n    </Section>\n    <h6>{`Note: this feature will be introduced in version `}<strong parentName=\"h6\">{`0.18.0`}</strong></h6>\n    <p>{`GraphQL interfaces is represented in Morpheus with `}<inlineCode parentName=\"p\">{`TypeGuard`}</inlineCode>{`.\nin the following data type definition every use of `}<inlineCode parentName=\"p\">{`PersonInterface`}</inlineCode>{`\nwill be represented as GraphQL interface `}<inlineCode parentName=\"p\">{`Person`}</inlineCode>{` and allow server to\nresolve different types from union `}<inlineCode parentName=\"p\">{`PersonImplements`}</inlineCode>{`.`}</p>\n    <p>{`All types of the union `}<inlineCode parentName=\"p\">{`PersonImplements`}</inlineCode>{` must be objects\nand contain fields of type `}<inlineCode parentName=\"p\">{`Person`}</inlineCode>{`, otherwise the derivation fails.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`  -- interface Person\ndata Person m = Person { name ::  m Text }\n  deriving\n    (\n      Generic,\n      GQLType\n    )\n\ndata PersonImplements m\n  = PersonImplementsUser (User m)\n  | PersonImplementsDeity (Deity m)\n  deriving\n    (\n      Generic,\n      GQLType\n    )\n\n-- typeGuard guards all variabts of union with person fields\ntype PersonInterface m = TypeGuard Person (PersonImplements m)`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"unions\" level={2} mdxType=\"Section\">\n  Unions\n    </Section>\n    <p>{`To use union type, all you have to do is derive the `}<inlineCode parentName=\"p\">{`GQLType`}</inlineCode>{` class. Using GraphQL `}<a parentName=\"p\" {...{\n        \"href\": \"https://graphql.org/learn/queries/#fragments\"\n      }}><em parentName=\"a\">{`fragments`}</em></a>{`, the arguments of each data constructor can be accessed from the GraphQL client.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Character\n  = CharacterDeity Deity -- will be unwrapped, since Character + Deity = CharacterDeity\n  | SomeDeity Deity -- will be wrapped since Character + Deity != SomeDeity\n  | Creature { creatureName :: Text, creatureAge :: Int }\n  | Demigod Text Text\n  | Zeus\n  deriving (Generic, GQLType)`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`where `}<inlineCode parentName=\"p\">{`Deity`}</inlineCode>{` is an object.`}</p>\n    <p>{`As we see, there are different kinds of unions. `}<inlineCode parentName=\"p\">{`Morpheus`}</inlineCode>{` handles them all.`}</p>\n    <p>{`This type will be represented as`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"graphql\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`union Character = Deity | SomeDeity | Creature | SomeMulti | Zeus\n\ntype SomeDeity {\n  _0: Deity!\n}\n\ntype Creature {\n  creatureName: String!\n  creatureAge: Int!\n}\n\ntype Demigod {\n  _0: Int!\n  _1: String!\n}\n\ntype Zeus {\n  _: Unit!\n}`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`By default, union members will be generated with wrapper objects.\nThere is one exception to this: if a constructor of a type is the type name concatenated with the name of the contained type, it will be referenced directly.\nThat is, given:`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Song = { songName :: Text, songDuration :: Float } deriving (Generic, GQLType)\n\ndata Skit = { skitName :: Text, skitDuration :: Float } deriving (Generic, GQLType)\n\ndata WrappedNode\n  = WrappedSong Song\n  | WrappedSkit Skit\n  deriving (Generic, GQLType)\n\ndata NonWrapped\n  = NonWrappedSong Song\n  | NonWrappedSkit Skit\n  deriving (Generic, GQLType)\n`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`You will get the following schema:`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"graphql\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`# has wrapper types\nunion WrappedNode = WrappedSong | WrappedSkit\n\n# is a direct union\nunion NonWrapped = Song | Skit\n\ntype WrappedSong {\n  _0: Song!\n}\n\ntype WrappedSKit {\n  _0: Skit!\n}\n\ntype Song {\n  songDuration: Float!\n  songName: String!\n}\n\ntype Skit {\n  skitDuration: Float!\n  skitName: String!\n}`}</code>{`\n        `}</deckgo-highlight-code>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`for all other unions will be generated new object type. for types without record syntax, fields will be automatically indexed.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`empty constructors will get field `}<inlineCode parentName=\"p\">{`_`}</inlineCode>{`associaced with type `}<inlineCode parentName=\"p\">{`Unit`}</inlineCode>{`.`}</p>\n      </li>\n    </ul>\n    <Section id=\"inputs\" level={2} mdxType=\"Section\">\n  Input types\n    </Section>\n    <p>{`Like object types, input types are represented by Haskell records.\nHowever, they are not permitted to have monad parameters, as they represent serialisable values.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Deity = Deity\n  { name :: Text         -- Non-Nullable Field\n  , power :: Maybe Text   -- Nullable Field\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","import React, { useContext } from \"react\";\nimport { NavContext } from \"./nav-context\";\n\nconst style = {\n  color: \"black\",\n  textDecoration: \"none\",\n  padding: \"0.1rem 0rem\",\n};\n\nexport const Section = ({ id, children, level = 1 }) => {\n  const [, setItem] = useContext(NavContext);\n\n  setItem({ id, level, children });\n\n  return level === 1 ? (\n    <h2 id={`${id}`} style={style}>\n      {children}\n    </h2>\n  ) : (\n    <h3 id={`${id}`} style={style}>\n      {children}\n    </h3>\n  );\n};\n\nexport default Section;\n"],"sourceRoot":""}