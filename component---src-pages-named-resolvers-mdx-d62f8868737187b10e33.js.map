{"version":3,"file":"component---src-pages-named-resolvers-mdx-d62f8868737187b10e33.js","mappings":"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","sources":["webpack://morpheus-graphql-docs/./src/components/section.js","webpack://morpheus-graphql-docs/./src/pages/named-resolvers.mdx"],"sourcesContent":["import React, { useContext } from \"react\";\nimport { NavContext } from \"./nav-context\";\n\nconst style = {\n  color: \"black\",\n  textDecoration: \"none\",\n  padding: \"0.1rem 0rem\",\n};\n\nexport const Section = ({ id, children, level = 1 }) => {\n  const [, setItem] = useContext(NavContext);\n\n  setItem({ id, level, children });\n\n  return level === 1 ? (\n    <h2 id={`${id}`} style={style}>\n      {children}\n    </h2>\n  ) : (\n    <h3 id={`${id}`} style={style}>\n      {children}\n    </h3>\n  );\n};\n\nexport default Section;\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/morpheus-graphql/morpheus-graphql/docs/src/components/layout.js\";\nimport { Link } from \"gatsby\";\nimport Layout from \"../components/layout\";\nimport SEO from \"../components/seo\";\nimport Section from \"../components/section\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n\n    <SEO title=\"Named Resolvers\" keywords={[\"Morpheus GraphQL\", \"GraphQL\", \"Haskell\"]} mdxType=\"SEO\" />\n    <h1>{`Resolving`}</h1>\n    <p>{`Morpheus GraphQL provides two way of type resolving.`}</p>\n    <ol>\n      <li parentName=\"ol\"><strong parentName=\"li\">{`Values as resolvers`}</strong>{`: In this approach, you specify values\nfor the type definitions, where the resolvers are regular functions.`}</li>\n      <li parentName=\"ol\"><strong parentName=\"li\">{`Named resolvers`}</strong>{`: In this approach, we use the type class `}<inlineCode parentName=\"li\">{`ResolveNamed`}</inlineCode>{` to define the\nresolver for each type. More information on this approach can be\nfound in the next section.`}</li>\n    </ol>\n    <Section id=\"named-resolvers\" level={1} mdxType=\"Section\">\n  Named Resolvers\n    </Section>\n    <h6>{`Note: this feature will be introduced in version `}<strong parentName=\"h6\">{`0.18.0`}</strong></h6>\n    <p>{`As mentioned earlier, in this approach we use `}<inlineCode parentName=\"p\">{`ResolveNamed`}</inlineCode>{`\nto define the resolver function for each type. In this resolver definition,\neach type also defines its dependency (identifier), which is used by the\ncompiler to provide a corresponding output resolution for certain input values.\nThat is, if we want to resolve a type as a field of another type, we must\nspecify a type dependency value for that particular type\ninstead of the type value. For a better illustration,\nlet's look at the following example:`}</p>\n    <Section id=\"app-posts\" level={2} mdxType=\"Section\">\n  App/Posts.hs\n    </Section>\n    <p>{`Let's say we want to create a GraphQL app for\na blogging website where we can either retrieve\nall posts or retrieve them by ID. Scheme definition for this\napplication would be as follows.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`newtype Post m = Post\n  { title :: m Text\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )\n\ndata Query m = Query\n  { posts :: m [Post m],\n    post :: Arg \"id\" ID -> m (Maybe (Post m))\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`Now that we have type definitions, we can define their resolvers,\nstarting with type `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{`. The following instance specifies that for each unique `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{`\nwe can resolve the corresponding `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{`, where the post `}<inlineCode parentName=\"p\">{`title`}</inlineCode>{` is retrieved by the post `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`instance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { title = resolve (getPostTitleById uid)\n        }`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`Let's go to the next step and define a query resolver. Since the query does not\nrequire an ID, we define its dependency with the unit type.`}</p>\n    <p>{`To resolve the `}<inlineCode parentName=\"p\">{`post`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`posts`}</inlineCode>{` fields, we only get post ids and\npass them to the resolve function, which then resolves the\ncorresponding `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` values by calling the `}<inlineCode parentName=\"p\">{`ResolveNamed`}</inlineCode>{`\ninstance of the type `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` with those ids.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`instance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { posts = resolve getPostIds,\n          post = \\\\(Arg arg) -> resolve (pure (Just arg))\n        }`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`In the last step, we can derive the GraphQL application using\nthe data type `}<inlineCode parentName=\"p\">{`NamedResolvers`}</inlineCode>{` by using a single constructor\n`}<inlineCode parentName=\"p\">{`NamedResolvers`}</inlineCode>{` without any fields.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`postsApp :: App () IO\npostsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`In the background, the function `}<inlineCode parentName=\"p\">{`deriveApp`}</inlineCode>{` traverses the data types and calls their\nown instances of `}<inlineCode parentName=\"p\">{`NamedResolver`}</inlineCode>{` for each object and union type. In this way,\na `}<inlineCode parentName=\"p\">{`ResolverMaps`}</inlineCode>{` (with type `}<inlineCode parentName=\"p\">{`Map TypeName (DependencyValue -> ResolveValue)`}</inlineCode>{`) is derived that can\nbe used in GraphQL query execution.`}</p>\n    <p>{`As you can see, the `}<inlineCode parentName=\"p\">{`ResolverMaps`}</inlineCode>{` derived in this way can be\nmerged if the types with the same name have the same GraphQL\nkind and the same dependency.\nTherefore, types in applications derived with `}<inlineCode parentName=\"p\">{`NamedResolvers`}</inlineCode>{` can be safely extended,\nwhich we will see in the next section.`}</p>\n    <Section id=\"app-authors\" level={2} mdxType=\"Section\">\n  App/Authors.hs\n    </Section>\n    <p>{`Let's say there is another team that wants to use the `}<inlineCode parentName=\"p\">{`Posts`}</inlineCode>{` application as well,\nbut also needs to provide `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{` information. The new application should\nallow querying of all existing `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{` and extend the post type with the field `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{`.`}</p>\n    <p>{`One way to address these new requirements would be to rewrite our old application,\nbut that will impact (or even break) the existing application. Here, named resolvers can\nbe of additional help to us, as `}<inlineCode parentName=\"p\">{`Apps`}</inlineCode>{` derived with named resolvers can be merged.\nWe can define our `}<inlineCode parentName=\"p\">{`Authors`}</inlineCode>{` app separately and then merge it with the existing one.`}</p>\n    <p>{`In the following code snippets we define the Author and Query types.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Author m = Author\n  { name :: m Text,\n    posts :: m [Post m]\n  } deriving (Generic, GQLType)\n\ndata Query m = Query\n  { authors :: m [Author m]\n  }\n  deriving (Generic, GQLType)`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`As you can see, we can query `}<inlineCode parentName=\"p\">{`authors`}</inlineCode>{`, with each `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` having their fields `}<inlineCode parentName=\"p\">{`name`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`posts`}</inlineCode>{`.\nin the same manner as before, we can also provide their resolver implementation.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`instance Monad m => ResolveNamed m (Author (NamedResolverT m)) where\n  type Dep (Author (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Author\n        { name = resolve (getAuthorName uid),\n          posts = resolve (getAuthorPosts uid)\n        }\n\ninstance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () = pure Query { authors = resolve getAuthorIds }`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`At this stage, we have already implemented Authors and Query and now we can also\nstart thinking about the Post Type.`}</p>\n    <p>{`First note, that the post type used in this app does not need to\nbe imported from the `}<inlineCode parentName=\"p\">{`App/Posts.hs`}</inlineCode>{`. We can simply define our type `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` with the new\nfield `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{` and all other fields associated with the post type will be automatically\ncompleted by the app `}<inlineCode parentName=\"p\">{`App/Posts.hs`}</inlineCode>{`, after the merging.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`-- is alternative to extend type\nnewtype Post m = Post\n  { author :: m (Author m)\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`Now we can start implementing the resolver for it.\nIt is of critical importance here, that the dependency of this type\nis the same as the dependency of `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` in `}<inlineCode parentName=\"p\">{`App/Posts.hs`}</inlineCode>{`. If the\nargument of the function does not match, one of the implementations\nwill be unable to decode the argument during resolution and it will fail.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`instance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { author = resolve (pure uid)\n        }`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`Since all resolvers are implemented, we can also derive the application.\nNote that this application can be used as a standalone application, however\nthe standalone version can only display the information provided by the Authors,\ni.e. the Post type will only have one field authors,\nand in the query we can only access authors.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`authorsApp :: App () IO\nauthorsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`However, if we want to access information from both apps,\nthe next section will show us how to merge them.`}</p>\n    <Section id=\"merged-app\" level={2} mdxType=\"Section\">\n  App.hs\n    </Section>\n    <p>{`The data type `}<inlineCode parentName=\"p\">{`App`}</inlineCode>{` has a `}<inlineCode parentName=\"p\">{`Semigroup`}</inlineCode>{` instance that allows to\njoin multiple apps together.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`app :: App () IO\napp = authorsApp <> postsApp`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`Since both the `}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` type definitions have the same dependency `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{`,\nthe interpreter safely merge these two apps where type\n`}<inlineCode parentName=\"p\">{`Post`}</inlineCode>{` will be extended with new field `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["style","color","textDecoration","padding","Section","id","children","level","setItem","useContext","NavContext","_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","title","keywords","parentName","isMDXComponent"],"sourceRoot":""}