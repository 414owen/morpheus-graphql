(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{pfKO:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return p})),n.d(t,"default",(function(){return b}));var a=n("zLVn"),i=(n("q1tI"),n("7ljp")),r=n("Bl7J"),o=(n("Wbzz"),n("vrFN")),l=["components"],p={},c={_frontmatter:p},s=r.a;function b(e){var t=e.components,n=Object(a.a)(e,l);return Object(i.b)(s,Object.assign({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)(o.a,{title:"Home",keywords:["Morpheus GraphQL","GraphQL","Haskell"],mdxType:"SEO"}),Object(i.b)("h1",null,"Morpheus GraphQL ",Object(i.b)("a",{parentName:"h1",href:"https://hackage.haskell.org/package/morpheus-graphql"},Object(i.b)("img",{parentName:"a",src:"https://img.shields.io/hackage/v/morpheus-graphql.svg",alt:"Hackage"}))," ",Object(i.b)("img",{parentName:"h1",src:"https://github.com/morpheusgraphql/morpheus-graphql/workflows/CI/badge.svg",alt:"CI"})),Object(i.b)("p",null,"Build GraphQL APIs with your favorite functional language!"),Object(i.b)("p",null,"Morpheus GraphQL (Server & Client) helps you to build GraphQL APIs in Haskell with native Haskell types.\nMorpheus will convert your Haskell types to a GraphQL schema and all your resolvers are just native Haskell functions. Morpheus GraphQL can also convert your GraphQL Schema or Query to Haskell types and validate them in compile time."),Object(i.b)("p",null,"Morpheus is still in an early stage of development, so any feedback is more than welcome, and we appreciate any contribution!\nJust open an issue here on GitHub, or join ",Object(i.b)("a",{parentName:"p",href:"https://morpheus-graphql-slack-invite.herokuapp.com/"},"our Slack channel")," to get in touch."),Object(i.b)("h2",null,"Getting Started"),Object(i.b)("h3",null,"Setup"),Object(i.b)("p",null,"To get started with Morpheus, you first need to add it to your project's dependencies, as follows (assuming you're using hpack):"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"package.yml")),Object(i.b)("deckgo-highlight-code",{language:"yaml",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"dependencies:\n  - morpheus-graphql"),"\n        "),Object(i.b)("p",null,"Additionally, you should tell stack which version to pick:"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"stack.yml")),Object(i.b)("deckgo-highlight-code",{language:"yaml",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"resolver: lts-16.2\n\nextra-deps:\n  - morpheus-graphql-0.17.0"),"\n        "),Object(i.b)("p",null,"As Morpheus is quite new, make sure stack can find morpheus-graphql by running ",Object(i.b)("inlineCode",{parentName:"p"},"stack upgrade")," and ",Object(i.b)("inlineCode",{parentName:"p"},"stack update")),Object(i.b)("h3",null,"Building your first GraphQL API"),Object(i.b)("h3",null,"with GraphQL syntax"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"schema.gql")),Object(i.b)("deckgo-highlight-code",{language:"graphql",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'type Query {\n  deity(name: String! = "Morpheus"): Deity!\n}\n\n"""\nDescription for Deity\n"""\ntype Deity {\n  """\n  Description for name\n  """\n  name: String!\n  power: String @deprecated(reason: "some reason for")\n}'),"\n        "),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"API.hs")),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule API (api) where\n\nimport Data.ByteString.Lazy.Char8 (ByteString)\nimport Data.Morpheus (interpreter)\nimport Data.Morpheus.Document (importGQLDocument)\nimport Data.Morpheus.Types (RootResolver (..), Undefined (..))\nimport Data.Text (Text)\n\nimportGQLDocument "schema.gql"\n\nrootResolver :: RootResolver IO () Query Undefined Undefined\nrootResolver =\n  RootResolver\n    { queryResolver = Query {deity},\n      mutationResolver = Undefined,\n      subscriptionResolver = Undefined\n    }\n  where\n    deity DeityArgs {name} =\n      pure\n        Deity\n          { name = pure name,\n            power = pure (Just "Shapeshifting")\n          }\n\napi :: ByteString -> IO ByteString\napi = interpreter rootResolver'),"\n        "),Object(i.b)("p",null,"Template Haskell Generates types: ",Object(i.b)("inlineCode",{parentName:"p"},"Query")," , ",Object(i.b)("inlineCode",{parentName:"p"},"Deity"),", ",Object(i.b)("inlineCode",{parentName:"p"},"DeityArgs"),", that can be used by ",Object(i.b)("inlineCode",{parentName:"p"},"rootResolver")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"descriptions")," and ",Object(i.b)("inlineCode",{parentName:"p"},"deprecations")," will be displayed in introspection."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"importGQLDocumentWithNamespace")," will generate Types with namespaced fields. If you don't need namespace use ",Object(i.b)("inlineCode",{parentName:"p"},"importGQLDocument")),Object(i.b)("h3",null,"with Native Haskell Types"),Object(i.b)("p",null,"To define a GraphQL API with Morpheus we start by defining the API Schema as a native Haskell data type,\nwhich derives the ",Object(i.b)("inlineCode",{parentName:"p"},"Generic")," typeClass. Lazily resolvable fields on this ",Object(i.b)("inlineCode",{parentName:"p"},"Query")," type are defined via ",Object(i.b)("inlineCode",{parentName:"p"},"a -> ResolverQ () IO b"),", representing resolving a set of arguments ",Object(i.b)("inlineCode",{parentName:"p"},"a")," to a concrete value ",Object(i.b)("inlineCode",{parentName:"p"},"b"),"."),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"data Query m = Query\n  { deity :: DeityArgs -> m Deity\n  } deriving (Generic, GQLType)\n\ndata Deity = Deity\n  { fullName :: Text         -- Non-Nullable Field\n  , power    :: Maybe Text   -- Nullable Field\n  } deriving (Generic,GQLType)\n\ndata DeityArgs = DeityArgs\n  { name      :: Text        -- Required Argument\n  , mythology :: Maybe Text  -- Optional Argument\n  } deriving (Generic)"),"\n        "),Object(i.b)("p",null,"For each field in the ",Object(i.b)("inlineCode",{parentName:"p"},"Query")," type defined via ",Object(i.b)("inlineCode",{parentName:"p"},"a -> m b")," (like ",Object(i.b)("inlineCode",{parentName:"p"},"deity"),") we will define a resolver implementation that provides the values during runtime by referring to\nsome data source, e.g. a database or another API. Fields that are defined without ",Object(i.b)("inlineCode",{parentName:"p"},"a -> m b")," you can just provide a value."),Object(i.b)("p",null,"In above example, the field of ",Object(i.b)("inlineCode",{parentName:"p"},"DeityArgs")," could also be named using reserved identities (such as: ",Object(i.b)("inlineCode",{parentName:"p"},"type"),", ",Object(i.b)("inlineCode",{parentName:"p"},"where"),", etc), in order to avoid conflict, a prime symbol (",Object(i.b)("inlineCode",{parentName:"p"},"'"),") must be attached. For example, you can have:"),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"data DeityArgs = DeityArgs\n  { name      :: Text        -- Required Argument\n  , mythology :: Maybe Text  -- Optional Argument\n  , type'     :: Text\n  } deriving (Generic)"),"\n        "),Object(i.b)("p",null,"The field name in the final request will be ",Object(i.b)("inlineCode",{parentName:"p"},"type")," instead of ",Object(i.b)("inlineCode",{parentName:"p"},"type'"),". The Morpheus request parser converts each of the reserved identities in Haskell 2010 to their corresponding names internally. This also applies to selections."),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"resolveDeity :: DeityArgs -> ResolverQ e () Deity\nresolveDeity DeityArgs { name, mythology } = liftEither $ dbDeity name mythology\n\naskDB :: Text -> Maybe Text -> IO (Either String Deity)\naskDB = ..."),"\n        "),Object(i.b)("p",null,"To make this ",Object(i.b)("inlineCode",{parentName:"p"},"Query")," type available as an API, we define a ",Object(i.b)("inlineCode",{parentName:"p"},"RootResolver")," and feed it to the Morpheus ",Object(i.b)("inlineCode",{parentName:"p"},"interpreter"),". A ",Object(i.b)("inlineCode",{parentName:"p"},"RootResolver")," consists of ",Object(i.b)("inlineCode",{parentName:"p"},"query"),", ",Object(i.b)("inlineCode",{parentName:"p"},"mutation")," and ",Object(i.b)("inlineCode",{parentName:"p"},"subscription")," definitions, while we omit the latter for this example:"),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"rootResolver :: RootResolver IO () Query Undefined Undefined\nrootResolver =\n  RootResolver\n    { queryResolver = Query {deity = resolveDeity}\n    , mutationResolver = Undefined\n    , subscriptionResolver = Undefined\n    }\n\ngqlApi :: ByteString -> IO ByteString\ngqlApi = interpreter rootResolver"),"\n        "),Object(i.b)("p",null,"As you can see, the API is defined as ",Object(i.b)("inlineCode",{parentName:"p"},"ByteString -> IO ByteString")," which we can either invoke directly or use inside an arbitrary web framework\nsuch as ",Object(i.b)("inlineCode",{parentName:"p"},"scotty")," or ",Object(i.b)("inlineCode",{parentName:"p"},"serverless-haskell"),". We'll go for ",Object(i.b)("inlineCode",{parentName:"p"},"scotty")," in this example:"),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'main :: IO ()\nmain = scotty 3000 $ post "/api" $ raw =<< (liftIO . gqlApi =<< body)'),"\n        "),Object(i.b)("p",null,"If we now send a POST request to ",Object(i.b)("inlineCode",{parentName:"p"},"http://localhost:3000/api")," with a GraphQL Query as body for example in a tool like ",Object(i.b)("inlineCode",{parentName:"p"},"Insomnia"),":"),Object(i.b)("deckgo-highlight-code",{language:"graphql",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'query GetDeity {\n  deity(name: "Morpheus") {\n    fullName\n    power\n  }\n}'),"\n        "),Object(i.b)("p",null,"our query will be resolved!"),Object(i.b)("deckgo-highlight-code",{language:"json",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'{\n  "data": {\n    "deity": {\n      "fullName": "Morpheus",\n      "power": "Shapeshifting"\n    }\n  }\n}'),"\n        "),Object(i.b)("h2",null,"Advanced topics"),Object(i.b)("h3",null,"Applicative and Monad instance"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"Resolver")," type has ",Object(i.b)("inlineCode",{parentName:"p"},"Applicative")," and ",Object(i.b)("inlineCode",{parentName:"p"},"Monad")," instances that can be used to compose resolvers."),Object(i.b)("h3",null,"Introspection"),Object(i.b)("p",null,"Morpheus converts your schema to a GraphQL introspection automatically. You can use tools like ",Object(i.b)("inlineCode",{parentName:"p"},"Insomnia")," to take a\nlook at the introspection and validate your schema.\nIf you need a description for your GQLType inside of the introspection you can define the GQLType instance manually\nand provide an implementation for the ",Object(i.b)("inlineCode",{parentName:"p"},"description")," function:"),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'data Deity = Deity\n{ ...\n} deriving (Generic)\n\ninstance GQLType Deity where\n  description = const "A supernatural being considered divine and sacred"'),"\n        "),Object(i.b)("p",null,"screenshots from ",Object(i.b)("inlineCode",{parentName:"p"},"Insomnia")),Object(i.b)("p",null,Object(i.b)("img",{parentName:"p",src:"https://morpheusgraphql.com/assets/img/introspection/spelling.png",alt:"alt text",title:"spelling"}),"\n",Object(i.b)("img",{parentName:"p",src:"https://morpheusgraphql.com/assets/img/introspection/autocomplete.png",alt:"alt text",title:"autocomplete"}),"\n",Object(i.b)("img",{parentName:"p",src:"https://morpheusgraphql.com/assets/img/introspection/type.png",alt:"alt text",title:"type"})),Object(i.b)("h2",null,"Handling Errors"),Object(i.b)("p",null,"for errors you can use use either ",Object(i.b)("inlineCode",{parentName:"p"},"liftEither")," or ",Object(i.b)("inlineCode",{parentName:"p"},"MonadFail"),":\nat the and they have same result."),Object(i.b)("p",null,"with ",Object(i.b)("inlineCode",{parentName:"p"},"liftEither")),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'resolveDeity :: DeityArgs -> ResolverQ e IO Deity\nresolveDeity DeityArgs {} = liftEither $ dbDeity\n\ndbDeity ::  IO Either Deity\ndbDeity = pure $ Left "db error"'),"\n        "),Object(i.b)("p",null,"with ",Object(i.b)("inlineCode",{parentName:"p"},"MonadFail")),Object(i.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(i.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'resolveDeity :: DeityArgs -> ResolverQ e IO Deity\nresolveDeity DeityArgs { } = fail "db error"'),"\n        "),Object(i.b)("h2",null,"Morpheus CLI for Code Generating"),Object(i.b)("p",null,"you should use ",Object(i.b)("a",{parentName:"p",href:"https://github.com/morpheusgraphql/morpheus-graphql-cli"},"morpheus-graphql-cli")),Object(i.b)("h2",null,"Roadmap"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Medium future:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Stabilize API"),Object(i.b)("li",{parentName:"ul"},"Specification-isomorphic error handling"))),Object(i.b)("li",{parentName:"ul"},"Long term:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Support all possible GQL features"),Object(i.b)("li",{parentName:"ul"},"Performance optimization")))))}b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-index-mdx-756842e56aa86a7c0582.js.map