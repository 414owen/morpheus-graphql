"use strict";(self.webpackChunkmorpheus_graphql_docs=self.webpackChunkmorpheus_graphql_docs||[]).push([[372],{307:function(e,t,n){n.d(t,{$:function(){return r}});var o=n(7294),a=n(1280),i={color:"black",textDecoration:"none",padding:"0.1rem 0rem"},r=function(e){var t=e.id,n=e.children,r=e.level,s=void 0===r?1:r;return(0,(0,o.useContext)(a.L)[1])({id:t,level:s,children:n}),1===s?o.createElement("h2",{id:""+t,style:i},n):o.createElement("h3",{id:""+t,style:i},n)};t.Z=r},9267:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return p},default:function(){return m}});var o=n(1531),a=(n(7294),n(4983)),i=n(9882),r=(n(1597),n(9357)),s=n(307),l=["components"],p={},d={_frontmatter:p},h=i.Z;function m(e){var t=e.components,n=(0,o.Z)(e,l);return(0,a.kt)(h,Object.assign({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)(r.Z,{title:"Named Resolvers",keywords:["Morpheus GraphQL","GraphQL","Haskell"],mdxType:"SEO"}),(0,a.kt)("h1",null,"Resolving"),(0,a.kt)("p",null,"Morpheus GraphQL provides two way of type resolving."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Values as resolvers"),": In this approach, you specify values\nfor the type definitions, where the resolvers are regular functions."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Named resolvers"),": In this approach, we use the type class ",(0,a.kt)("inlineCode",{parentName:"li"},"ResolveNamed")," to define the\nresolver for each type. More information on this approach can be\nfound in the next section.")),(0,a.kt)(s.Z,{id:"named-resolvers",level:1,mdxType:"Section"},"Named Resolvers"),(0,a.kt)("p",null,"As mentioned earlier, in this approach we use ",(0,a.kt)("inlineCode",{parentName:"p"},"ResolveNamed"),"\nto define the resolver function for each type. In this resolver definition,\neach type also defines its dependency (identifier), which is used by the\ncompiler to provide a corresponding output resolution for certain input values.\nThat is, if we want to resolve a type as a field of another type, we must\nspecify a type dependency value for that particular type\ninstead of the type value. For a better illustration,\nlet's look at the following example:"),(0,a.kt)(s.Z,{id:"app-posts",level:2,mdxType:"Section"},"App/Posts.hs"),(0,a.kt)("p",null,"Let's say we want to create a GraphQL app for\na blogging website where we can either retrieve\nall posts or retrieve them by ID. Scheme definition for this\napplication would be as follows."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},'newtype Post m = Post\n  { title :: m Text\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )\n\ndata Query m = Query\n  { posts :: m [Post m],\n    post :: Arg "id" ID -> m (Maybe (Post m))\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )'),"\n        "),(0,a.kt)("p",null,"Now that we have type definitions, we can define their resolvers,\nstarting with type ",(0,a.kt)("inlineCode",{parentName:"p"},"Post"),". The following instance specifies that for each unique ",(0,a.kt)("inlineCode",{parentName:"p"},"ID"),"\nwe can resolve the corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"Post"),", where the post ",(0,a.kt)("inlineCode",{parentName:"p"},"title")," is retrieved by the post ",(0,a.kt)("inlineCode",{parentName:"p"},"ID"),"."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { title = resolve (getPostTitleById uid)\n        }"),"\n        "),(0,a.kt)("p",null,"Let's go to the next step and define a query resolver. Since the query does not\nrequire an ID, we define its dependency with the unit type."),(0,a.kt)("p",null,"To resolve the ",(0,a.kt)("inlineCode",{parentName:"p"},"post")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"posts")," fields, we only get post ids and\npass them to the resolve function, which then resolves the\ncorresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," values by calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"ResolveNamed"),"\ninstance of the type ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," with those ids."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { posts = resolve getPostIds,\n          post = \\(Arg arg) -> resolve (pure (Just arg))\n        }"),"\n        "),(0,a.kt)("p",null,"In the last step, we can derive the GraphQL application using\nthe data type ",(0,a.kt)("inlineCode",{parentName:"p"},"NamedResolvers")," by using a single constructor\n",(0,a.kt)("inlineCode",{parentName:"p"},"NamedResolvers")," without any fields."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"postsApp :: App () IO\npostsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)"),"\n        "),(0,a.kt)("p",null,"In the background, the function ",(0,a.kt)("inlineCode",{parentName:"p"},"deriveApp")," traverses the data types and calls their\nown instances of ",(0,a.kt)("inlineCode",{parentName:"p"},"NamedResolver")," for each object and union type. In this way,\na ",(0,a.kt)("inlineCode",{parentName:"p"},"ResolverMaps")," (with type ",(0,a.kt)("inlineCode",{parentName:"p"},"Map TypeName (DependencyValue -> ResolveValue)"),") is derived that can\nbe used in GraphQL query execution."),(0,a.kt)("p",null,"As you can see, the ",(0,a.kt)("inlineCode",{parentName:"p"},"ResolverMaps")," derived in this way can be\nmerged if the types with the same name have the same GraphQL\nkind and the same dependency.\nTherefore, types in applications derived with ",(0,a.kt)("inlineCode",{parentName:"p"},"NamedResolvers")," can be safely extended,\nwhich we will see in the next section."),(0,a.kt)(s.Z,{id:"app-authors",level:2,mdxType:"Section"},"App/Authors.hs"),(0,a.kt)("p",null,"Let's say there is another team that wants to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"Posts")," application as well,\nbut also needs to provide ",(0,a.kt)("inlineCode",{parentName:"p"},"Authors")," information. The new application should\nallow querying of all existing ",(0,a.kt)("inlineCode",{parentName:"p"},"Authors")," and extend the post type with the field ",(0,a.kt)("inlineCode",{parentName:"p"},"author"),"."),(0,a.kt)("p",null,"One way to address these new requirements would be to rewrite our old application,\nbut that will impact (or even break) the existing application. Here, named resolvers can\nbe of additional help to us, as ",(0,a.kt)("inlineCode",{parentName:"p"},"Apps")," derived with named resolvers can be merged.\nWe can define our ",(0,a.kt)("inlineCode",{parentName:"p"},"Authors")," app separately and then merge it with the existing one."),(0,a.kt)("p",null,"In the following code snippets we define the Author and Query types."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"data Author m = Author\n  { name :: m Text,\n    posts :: m [Post m]\n  } deriving (Generic, GQLType)\n\ndata Query m = Query\n  { authors :: m [Author m]\n  }\n  deriving (Generic, GQLType)"),"\n        "),(0,a.kt)("p",null,"As you can see, we can query ",(0,a.kt)("inlineCode",{parentName:"p"},"authors"),", with each ",(0,a.kt)("inlineCode",{parentName:"p"},"Author")," having their fields ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"posts"),".\nin the same manner as before, we can also provide their resolver implementation."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Author (NamedResolverT m)) where\n  type Dep (Author (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Author\n        { name = resolve (getAuthorName uid),\n          posts = resolve (getAuthorPosts uid)\n        }\n\ninstance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () = pure Query { authors = resolve getAuthorIds }"),"\n        "),(0,a.kt)("p",null,"At this stage, we have already implemented Authors and Query and now we can also\nstart thinking about the Post Type."),(0,a.kt)("p",null,"First note, that the post type used in this app does not need to\nbe imported from the ",(0,a.kt)("inlineCode",{parentName:"p"},"App/Posts.hs"),". We can simply define our type ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," with the new\nfield ",(0,a.kt)("inlineCode",{parentName:"p"},"author")," and all other fields associated with the post type will be automatically\ncompleted by the app ",(0,a.kt)("inlineCode",{parentName:"p"},"App/Posts.hs"),", after the merging."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"-- is alternative to extend type\nnewtype Post m = Post\n  { author :: m (Author m)\n  } deriving\n    ( Generic\n    , GQLType\n    )"),"\n        "),(0,a.kt)("p",null,"Now we can start implementing the resolver for it.\nIt is of critical importance here, that the dependency of this type\nis the same as the dependency of ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"App/Posts.hs"),". If the\nargument of the function does not match, one of the implementations\nwill be unable to decode the argument during resolution and it will fail."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { author = resolve (pure uid)\n        }"),"\n        "),(0,a.kt)("p",null,"Since all resolvers are implemented, we can also derive the application.\nNote that this application can be used as a standalone application, however\nthe standalone version can only display the information provided by the Authors,\ni.e. the Post type will only have one field authors,\nand in the query we can only access authors."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"authorsApp :: App () IO\nauthorsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)"),"\n        "),(0,a.kt)("p",null,"However, if we want to access information from both apps,\nthe next section will show us how to merge them."),(0,a.kt)(s.Z,{id:"merged-app",level:2,mdxType:"Section"},"App.hs"),(0,a.kt)("p",null,"The data type ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," has a ",(0,a.kt)("inlineCode",{parentName:"p"},"Semigroup")," instance that allows to\njoin multiple apps together."),(0,a.kt)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",(0,a.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"app :: App () IO\napp = authorsApp <> postsApp"),"\n        "),(0,a.kt)("p",null,"Since both the ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," type definitions have the same dependency ",(0,a.kt)("inlineCode",{parentName:"p"},"ID"),",\nthe interpreter safely merge these two apps where type\n",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," will be extended with new field ",(0,a.kt)("inlineCode",{parentName:"p"},"author"),"."))}m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-named-resolvers-mdx-babb01d90a18e1b3ba66.js.map