(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{u9oG:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return l})),t.d(n,"default",(function(){return c}));var o=t("zLVn"),a=(t("q1tI"),t("7ljp")),r=t("Bl7J"),i=(t("Wbzz"),t("vrFN")),s=["components"],l={},p={_frontmatter:l},d=r.a;function c(e){var n=e.components,t=Object(o.a)(e,s);return Object(a.b)(d,Object.assign({},p,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)(i.a,{title:"Named Resolvers",keywords:["Morpheus GraphQL","GraphQL","Haskell"],mdxType:"SEO"}),Object(a.b)("h1",null,"Resolving"),Object(a.b)("p",null,"Morpheus GraphQL provides two way of the type resolving."),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Values as resolvers"),": In this approach, you just specify values\nfor the type definitions, where the resolvers are regular functions."),Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Named resolvers"),": In this approach, we use the type class ",Object(a.b)("inlineCode",{parentName:"li"},"ResolveNamed")," to define the\nresolver for each type. More information on this approach can be\nfound in the next section.")),Object(a.b)("h2",null,"Named Resolvers"),Object(a.b)("h6",null,"Note: this feature will be introduced in version ",Object(a.b)("strong",{parentName:"h6"},"0.18.0")),Object(a.b)("p",null,"As mentioned earlier, in this approach we use ",Object(a.b)("inlineCode",{parentName:"p"},"ResolveNamed"),"\nto define the resolver function for each type. In this resolver definition,\neach type also defines its dependency (identifier), which is used by the\ncompiler to provide a corresponding output resolution for certain input values.\nThat is, if we want to resolve a type as a field of another type, we must\nspecify a type dependency value for that particular type\ninstead of the type value. For a better illustration,\nlet's look at the following example:"),Object(a.b)("p",null,"Let's say we want to create a GraphQL app for\na blogging website where we can either retrieve\nall posts or retrieve them by ID. Scheme definition for this\napplication would be as follows."),Object(a.b)("h3",null,"App/Posts.hs"),Object(a.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(a.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'newtype Post m = Post\n  { title :: m Text\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )\n\ndata Query m = Query\n  { posts :: m [Post m],\n    post :: Arg "id" ID -> m (Maybe (Post m))\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )'),"\n        "),Object(a.b)("p",null,"Now that we have type definitions, we can define their resolvers,\nstarting with type ",Object(a.b)("inlineCode",{parentName:"p"},"Post"),". The following instance specifies that for each unique ",Object(a.b)("inlineCode",{parentName:"p"},"ID"),"\nwe can resolve the corresponding ",Object(a.b)("inlineCode",{parentName:"p"},"Post"),", where the post ",Object(a.b)("inlineCode",{parentName:"p"},"title")," is retrieved by the post ",Object(a.b)("inlineCode",{parentName:"p"},"ID"),"."),Object(a.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(a.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { title = resolve (getPostTitleById uid)\n        }"),"\n        "),Object(a.b)("p",null,"Let's go to the next stage and define query resolver. Since the query does not\nrequire an ID, we define its dependency with the unit type."),Object(a.b)("p",null,"To resolve the ",Object(a.b)("inlineCode",{parentName:"p"},"post")," and ",Object(a.b)("inlineCode",{parentName:"p"},"posts")," fields, we only get post-ids and\npass them to the resolve function, which automatically resolves the\ncorresponding ",Object(a.b)("inlineCode",{parentName:"p"},"Post")," values by calling the ",Object(a.b)("inlineCode",{parentName:"p"},"ResolveNamed"),"\ninstance of the type ",Object(a.b)("inlineCode",{parentName:"p"},"Post")," with those ids."),Object(a.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(a.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { posts = resolve getPostIds,\n          post = \\(Arg arg) -> resolve (pure (Just arg))\n        }"),"\n        "),Object(a.b)("p",null,"In the last step, we can derive the GraphQL application using\nthe data type ",Object(a.b)("inlineCode",{parentName:"p"},"NamedResolvers")," by using a single constructor\n",Object(a.b)("inlineCode",{parentName:"p"},"NamedResolvers")," without any fields."),Object(a.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(a.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"postsApp :: App () IO\npostsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)"),"\n        "),Object(a.b)("p",null,"in the background, the function ",Object(a.b)("inlineCode",{parentName:"p"},"deriveApp")," traverses the data types and calls their\nown instances of ",Object(a.b)("inlineCode",{parentName:"p"},"NamedResolver")," for each object and union type. In this way,\na ",Object(a.b)("inlineCode",{parentName:"p"},"ResolverMaps")," (with type ",Object(a.b)("inlineCode",{parentName:"p"},"Map TypeName (DependencyValue -> ResolveValue)"),") is derived that can\nbe used in GraphQL query execution."),Object(a.b)("p",null,"As you can notice, the ",Object(a.b)("inlineCode",{parentName:"p"},"ResolverMaps")," derived in this way can be\nmerged if the types with the same name have the same GraphQL\nkind and the same dependency.\nTherefore, types in applications derived with ",Object(a.b)("inlineCode",{parentName:"p"},"NamedResolvers")," can be safely extended,\nwhich we will see in the next section."),Object(a.b)("h3",null,"App/Authors.hs"),Object(a.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(a.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'data Author m = Author\n  { name :: m Text,\n    posts :: m [Post m]\n  } deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Author (NamedResolverT m)) where\n  type Dep (Author (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Author\n        { name = resolve (getAuthorName uid),\n          posts = resolve (getAuthorPosts uid)\n        }\n\n-- is alternative to extend type\nnewtype Post m = Post\n  { author :: m (Author m)\n  } deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { author = resolve (pure uid)\n        }\n\n-- QUERY\ndata Query m = Query\n  { authors :: m [Author m],\n    authorById :: Arg "id" ID -> m (Maybe (Author m))\n  }\n  deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { authors = resolve getAuthorIds,\n          authorById = \\(Arg uid) -> resolve (pure (Just uid))\n        }\n\nauthorsApp :: App () IO\nauthorsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)'),"\n        "),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"App.hs")),Object(a.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(a.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"app :: App () IO\napp = authorsApp <> postsApp"),"\n        "),Object(a.b)("p",null,"since the both ",Object(a.b)("inlineCode",{parentName:"p"},"Post")," type definitions have same dependency ",Object(a.b)("inlineCode",{parentName:"p"},"ID"),",\nthe interpreter safelly merge this two apps where type\n",Object(a.b)("inlineCode",{parentName:"p"},"Post")," will be extended with new field ",Object(a.b)("inlineCode",{parentName:"p"},"author"),"."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-named-resolvers-mdx-eeba4222e53c20ce27b7.js.map