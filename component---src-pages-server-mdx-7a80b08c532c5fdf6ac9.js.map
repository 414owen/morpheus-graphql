{"version":3,"file":"component---src-pages-server-mdx-7a80b08c532c5fdf6ac9.js","mappings":"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","sources":["webpack://morpheus-graphql-docs/./src/components/section.js","webpack://morpheus-graphql-docs/./src/pages/server.mdx"],"sourcesContent":["import React, { useContext } from \"react\";\nimport { NavContext } from \"./nav-context\";\n\nconst style = {\n  color: \"black\",\n  textDecoration: \"none\",\n  padding: \"0.1rem 0rem\",\n};\n\nexport const Section = ({ id, children, level = 1 }) => {\n  const [, setItem] = useContext(NavContext);\n\n  setItem({ id, level, children });\n\n  return level === 1 ? (\n    <h2 id={`${id}`} style={style}>\n      {children}\n    </h2>\n  ) : (\n    <h3 id={`${id}`} style={style}>\n      {children}\n    </h3>\n  );\n};\n\nexport default Section;\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/morpheus-graphql/morpheus-graphql/docs/src/components/layout.js\";\nimport SEO from \"../components/seo\";\nimport { Section } from \"../components/section\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <SEO title=\"Type System\" keywords={[\"Morpheus GraphQL\", \"GraphQL\", \"Haskell\", \"Type System\"]} mdxType=\"SEO\" />\n    <h1>{`Server`}</h1>\n    <Section id=\"type-system\" mdxType=\"Section\">Type System</Section>\n    <p>{`Morpheus GraphQL covers all GraphQL data types with an equivalent\nHaskell representation. A prerequisite for these representation types is that\nthey must be derived by `}<inlineCode parentName=\"p\">{`Generic`}</inlineCode>{` and provide corresponding `}<inlineCode parentName=\"p\">{`GQLType`}</inlineCode>{` instances.`}</p>\n    <Section id=\"objects\" level={2} mdxType=\"Section\">\n  Object types\n    </Section>\n    <p>{`Object types are represented in Morpheus with Haskell records,\nwhere the parameter `}<inlineCode parentName=\"p\">{`m`}</inlineCode>{` passes the resolution monad\nto the field resolution functions. The following code snippet, for example,\ndefines the type Deity with a nullable field `}<inlineCode parentName=\"p\">{`power`}</inlineCode>{` and a non-nullable field `}<inlineCode parentName=\"p\">{`name`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Deity m = Deity\n  { name :: m Text         -- Non-Nullable Field\n  , power :: m Maybe Text   -- Nullable Field\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"arguments\" level={3} mdxType=\"Section\">\n  Arguments\n    </Section>\n    <p>{`GraphQL arguments can be represented with two ways:`}</p>\n    <h4>{`Haskell records`}</h4>\n    <p>{`we can use Haskell records to declare GraphQL arguments,\nwhere each field of a record represents a particular\nargument, and can be accessed by name.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Query m = Query\n  { deity :: DeityArgs -> m Deity\n  } deriving\n    ( Generic\n    , GQLType\n    )\n\ndata DeityArgs = DeityArgs\n  { name      :: Text        -- Required Argument\n  , mythology :: Maybe Text  -- Optional Argument\n  } deriving\n     ( Generic,\n       GQLType\n     )`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`This approach is quite convenient for representing multiple arguments,\nbut cumbersome if we only need one argument for each field.\nThat is why we also introduce \"Tagged Arguments\".`}</p>\n    <h4>{`Tagged function arguments`}</h4>\n    <p>{`Tagged arguments leverage type-level literals and enable GraphQL\narguments to be represented as a chain of named function arguments.\ne.g. the following type defines GraphQL field `}<inlineCode parentName=\"p\">{`deity`}</inlineCode>{` with the\noptional argument `}<inlineCode parentName=\"p\">{`name`}</inlineCode>{` of type `}<inlineCode parentName=\"p\">{`String`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Query m = Query\n  { deity :: Arg \"name\" (Maybe Text) -> m Deity\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"query\" level={3} mdxType=\"Section\">\n  Query\n    </Section>\n    <p>{`the GraphQL query type is represented in Morpheus GraphQL as a regular object type named `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{`.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Query m = Query\n  { deity ::  m Deity\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"mutations\" level={3} mdxType=\"Section\">\n  Mutations\n    </Section>\n    <p>{`In addition to queries, Morpheus also supports mutations. They behave just like regular queries and are defined similarly:`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`newtype Mutation m = Mutation\n  { createDeity :: MutArgs -> m Deity\n  } deriving (Generic, GQLType)\n\nrootResolver :: RootResolver IO  () Query Mutation Undefined\nrootResolver =\n  RootResolver\n    { queryResolver = Query {...}\n    , mutationResolver = Mutation { createDeity }\n    , subscriptionResolver = Undefined\n    }\n    where\n      -- Mutation Without Event Triggering\n      createDeity :: MutArgs -> ResolverM () IO Deity\n      createDeity_args = lift setDBAddress\n\ngqlApi :: ByteString -> IO ByteString\ngqlApi = interpreter rootResolver`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"subscription\" level={3} mdxType=\"Section\">\n  Subscriptions\n    </Section>\n    <p>{`In morpheus subscription and mutation communicate with Events,\n`}<inlineCode parentName=\"p\">{`Event`}</inlineCode>{` consists with user defined `}<inlineCode parentName=\"p\">{`Channel`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Content`}</inlineCode>{`.`}</p>\n    <p>{`Every subscription has its own Channel by which it will be triggered`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Channel\n  = ChannelA\n  | ChannelB\n\ndata Content\n  = ContentA Int\n  | ContentB Text\n\ntype MyEvent = Event Channel Content\n\nnewtype Query m = Query\n  { deity :: m Deity\n  } deriving (Generic)\n\nnewtype Mutation m = Mutation\n  { createDeity :: m Deity\n  } deriving (Generic)\n\nnewtype Subscription (m ::  * -> * ) = Subscription\n  { newDeity :: m  Deity\n  } deriving (Generic)\n\nnewtype Subscription (m :: * -> *) = Subscription\n{ newDeity :: SubscriptionField (m Deity),\n}\nderiving (Generic)\n\n\ntype APIEvent = Event Channel Content\n\nrootResolver :: RootResolver IO APIEvent Query Mutation Subscription\nrootResolver = RootResolver\n  { queryResolver        = Query { deity = fetchDeity }\n  , mutationResolver     = Mutation { createDeity }\n  , subscriptionResolver = Subscription { newDeity }\n  }\n where\n  -- Mutation Without Event Triggering\n  createDeity :: ResolverM EVENT IO Address\n  createDeity = do\n      requireAuthorized\n      publish [Event { channels = [ChannelA], content = ContentA 1 }]\n      lift dbCreateDeity\n  newDeity :: SubscriptionField (ResolverS EVENT IO Deity)\n  newDeity = subscribe ChannelA $ do\n    -- executed only once\n    -- immediate response on failures\n    requireAuthorized\n    pure $ \\\\(Event _ content) -> do\n        -- executes on every event\n        lift (getDBAddress content)`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"scalars\" level={2} mdxType=\"Section\">\n  Scalar types\n    </Section>\n    <p>{`any Haskell data type can be represented as a GraphQL scalar type.\nIn order to do this, the type must be associated as\n`}<inlineCode parentName=\"p\">{`SCALAR`}</inlineCode>{` and implemented with `}<inlineCode parentName=\"p\">{`DecodeScalar`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`EncodeScalar`}</inlineCode>{` instances.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Odd = Odd Int  deriving (Generic)\n\ninstance DecodeScalar Euro where\n  decodeScalar (Int x) = pure $ Odd (... )\n  decodeScalar _ = Left \"invalid Value!\"\n\ninstance EncodeScalar Euro where\n  encodeScalar (Odd value) = Int value\n\ninstance GQLType Odd where\n  type KIND Odd = SCALAR`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"enums\" level={2} mdxType=\"Section\">\n  Enumeration types\n    </Section>\n    <p>{`Data types where all constructors are empty are derived as GraphQL enums.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data City\n  = Athens\n  | Sparta\n  | Corinth\n  | Delphi\n  | Argos\n  deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"wrappers\" level={2} mdxType=\"Section\">\n  Lists and Non-Null\n    </Section>\n    <p>{`GraphQL Lists are represented with Haskell Lists.\nHowever, since in Haskell each type is intrinsically not nullable,\nnullable GraphQL fields are represented with `}<inlineCode parentName=\"p\">{`Maybe`}</inlineCode>{` Haskell data type and non-nullable\nGraphQL fields with regular Haskell datatypes.`}</p>\n    <Section id=\"interfaces\" level={2} mdxType=\"Section\">\n  Interfaces\n    </Section>\n    <h6>{`Note: this feature will be introduced in version `}<strong parentName=\"h6\">{`0.18.0`}</strong></h6>\n    <p>{`GraphQL interfaces is represented in Morpheus with `}<inlineCode parentName=\"p\">{`TypeGuard`}</inlineCode>{`.\nin the following data type definition every use of `}<inlineCode parentName=\"p\">{`PersonInterface`}</inlineCode>{`\nwill be represented as GraphQL interface `}<inlineCode parentName=\"p\">{`Person`}</inlineCode>{` and allow server to\nresolve different types from union `}<inlineCode parentName=\"p\">{`PersonImplements`}</inlineCode>{`.`}</p>\n    <p>{`All types of the union `}<inlineCode parentName=\"p\">{`PersonImplements`}</inlineCode>{` must be objects\nand contain fields of type `}<inlineCode parentName=\"p\">{`Person`}</inlineCode>{`, otherwise the derivation fails.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`  -- interface Person\ndata Person m = Person { name ::  m Text }\n  deriving\n    (\n      Generic,\n      GQLType\n    )\n\ndata PersonImplements m\n  = PersonImplementsUser (User m)\n  | PersonImplementsDeity (Deity m)\n  deriving\n    (\n      Generic,\n      GQLType\n    )\n\n-- typeGuard guards all variabts of union with person fields\ntype PersonInterface m = TypeGuard Person (PersonImplements m)`}</code>{`\n        `}</deckgo-highlight-code>\n    <Section id=\"unions\" level={2} mdxType=\"Section\">\n  Unions\n    </Section>\n    <p>{`To use union type, all you have to do is derive the `}<inlineCode parentName=\"p\">{`GQLType`}</inlineCode>{` class. Using GraphQL `}<a parentName=\"p\" {...{\n        \"href\": \"https://graphql.org/learn/queries/#fragments\"\n      }}><em parentName=\"a\">{`fragments`}</em></a>{`, the arguments of each data constructor can be accessed from the GraphQL client.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Character\n  = CharacterDeity Deity -- will be unwrapped, since Character + Deity = CharacterDeity\n  | SomeDeity Deity -- will be wrapped since Character + Deity != SomeDeity\n  | Creature { creatureName :: Text, creatureAge :: Int }\n  | Demigod Text Text\n  | Zeus\n  deriving (Generic, GQLType)`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`where `}<inlineCode parentName=\"p\">{`Deity`}</inlineCode>{` is an object.`}</p>\n    <p>{`As we see, there are different kinds of unions. `}<inlineCode parentName=\"p\">{`Morpheus`}</inlineCode>{` handles them all.`}</p>\n    <p>{`This type will be represented as`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"graphql\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`union Character = Deity | SomeDeity | Creature | SomeMulti | Zeus\n\ntype SomeDeity {\n  _0: Deity!\n}\n\ntype Creature {\n  creatureName: String!\n  creatureAge: Int!\n}\n\ntype Demigod {\n  _0: Int!\n  _1: String!\n}\n\ntype Zeus {\n  _: Unit!\n}`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`By default, union members will be generated with wrapper objects.\nThere is one exception to this: if a constructor of a type is the type name concatenated with the name of the contained type, it will be referenced directly.\nThat is, given:`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Song = { songName :: Text, songDuration :: Float } deriving (Generic, GQLType)\n\ndata Skit = { skitName :: Text, skitDuration :: Float } deriving (Generic, GQLType)\n\ndata WrappedNode\n  = WrappedSong Song\n  | WrappedSkit Skit\n  deriving (Generic, GQLType)\n\ndata NonWrapped\n  = NonWrappedSong Song\n  | NonWrappedSkit Skit\n  deriving (Generic, GQLType)\n`}</code>{`\n        `}</deckgo-highlight-code>\n    <p>{`You will get the following schema:`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"graphql\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`# has wrapper types\nunion WrappedNode = WrappedSong | WrappedSkit\n\n# is a direct union\nunion NonWrapped = Song | Skit\n\ntype WrappedSong {\n  _0: Song!\n}\n\ntype WrappedSKit {\n  _0: Skit!\n}\n\ntype Song {\n  songDuration: Float!\n  songName: String!\n}\n\ntype Skit {\n  skitDuration: Float!\n  skitName: String!\n}`}</code>{`\n        `}</deckgo-highlight-code>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`for all other unions will be generated new object type. for types without record syntax, fields will be automatically indexed.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`empty constructors will get field `}<inlineCode parentName=\"p\">{`_`}</inlineCode>{`associaced with type `}<inlineCode parentName=\"p\">{`Unit`}</inlineCode>{`.`}</p>\n      </li>\n    </ul>\n    <Section id=\"inputs\" level={2} mdxType=\"Section\">\n  Input types\n    </Section>\n    <p>{`Like object types, input types are represented by Haskell records.\nHowever, they are not permitted to have monad parameters, as they represent serialisable values.`}</p>\n    <deckgo-highlight-code {...{\n      \"language\": \"haskell\",\n      \"terminal\": \"carbon\",\n      \"theme\": \"one-dark\",\n      \"line-numbers\": \"true\"\n    }}>{`\n          `}<code parentName=\"deckgo-highlight-code\" {...{\n        \"slot\": \"code\"\n      }}>{`data Deity = Deity\n  { name :: Text         -- Non-Nullable Field\n  , power :: Maybe Text   -- Nullable Field\n  } deriving\n    ( Generic\n    , GQLType\n    )`}</code>{`\n        `}</deckgo-highlight-code>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["style","color","textDecoration","padding","Section","id","children","level","setItem","useContext","NavContext","_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","title","keywords","parentName","isMDXComponent"],"sourceRoot":""}