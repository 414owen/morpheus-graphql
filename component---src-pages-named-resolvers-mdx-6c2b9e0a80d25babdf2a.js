(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{u9oG:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return l})),t.d(n,"default",(function(){return c}));var o=t("zLVn"),r=(t("q1tI"),t("7ljp")),a=t("Bl7J"),s=(t("Wbzz"),t("vrFN")),i=["components"],l={},p={_frontmatter:l},d=a.a;function c(e){var n=e.components,t=Object(o.a)(e,i);return Object(r.b)(d,Object.assign({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)(s.a,{title:"Named Resolvers",keywords:["Morpheus GraphQL","GraphQL","Haskell"],mdxType:"SEO"}),Object(r.b)("h1",null,"Resolving"),Object(r.b)("p",null,"Morpheus GraphQL provides two way of the type resolving."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Values as resolvers"),": In this approach, you just specify values\nfor the type definitions, where the resolvers are regular functions."),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Named resolvers"),": In this approach, we use the type class ",Object(r.b)("inlineCode",{parentName:"li"},"ResolveNamed")," to define the\nresolver for each type. More information on this approach can be\nfound in the next section.")),Object(r.b)("h2",null,"Named Resolvers"),Object(r.b)("h6",null,"Note: this feature will be introduced in version ",Object(r.b)("strong",{parentName:"h6"},"0.18.0")),Object(r.b)("p",null,"As mentioned earlier, in this approach we use ",Object(r.b)("inlineCode",{parentName:"p"},"ResolveNamed"),"\nto define the resolver function for each type. In this resolver definition,\neach type also defines its dependency (identifier), which is used by the\ncompiler to provide a corresponding output resolution for certain input values.\nThat is, if we want to resolve a type as a field of another type, we must\nspecify a type dependency value for that particular type\ninstead of the type value. For a better illustration,\nlet's look at the following example:"),Object(r.b)("p",null,"Let's say we want to create a GraphQL app for\na blogging website where we can either retrieve\nall posts or retrieve them by ID. Scheme definition for this\napplication would be as follows."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"App/Posts.hs")),Object(r.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(r.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'newtype Post m = Post\n  { title :: m Text\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )\n\ndata Query m = Query\n  { posts :: m [Post m],\n    post :: Arg "id" ID -> m (Maybe (Post m))\n  }\n  deriving\n    ( Generic,\n      GQLType\n    )'),"\n        "),Object(r.b)("p",null,"Now that we have type definitions, we can define their resolvers,\nstarting with type post. The following instance specifies that for each unique ",Object(r.b)("inlineCode",{parentName:"p"},"ID"),"\nwe can resolve the corresponding ",Object(r.b)("inlineCode",{parentName:"p"},"Post"),", where the post ",Object(r.b)("inlineCode",{parentName:"p"},"title")," is requested by the post ",Object(r.b)("inlineCode",{parentName:"p"},"ID"),"."),Object(r.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(r.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { title = resolve (getPostTitleById uid)\n        }"),"\n        "),Object(r.b)("p",null,"Let's go to the next stage and define query resolver."),Object(r.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(r.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"instance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { posts = resolve getPostIds,\n          post = \\(Arg arg) -> resolve (pure (Just arg))\n        }"),"\n        "),Object(r.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(r.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"postsApp :: App () IO\npostsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)"),"\n        "),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Authors.hs")),Object(r.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(r.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},'data Author m = Author\n  { name :: m Text,\n    posts :: m [Post m]\n  } deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Author (NamedResolverT m)) where\n  type Dep (Author (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Author\n        { name = resolve (getAuthorName uid),\n          posts = resolve (getAuthorPosts uid)\n        }\n\n-- is alternative to extend type\nnewtype Post m = Post\n  { author :: m (Author m)\n  } deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Post (NamedResolverT m)) where\n  type Dep (Post (NamedResolverT m)) = ID\n  resolveNamed uid =\n    pure\n      Post\n        { author = resolve (pure uid)\n        }\n\n-- QUERY\ndata Query m = Query\n  { authors :: m [Author m],\n    authorById :: Arg "id" ID -> m (Maybe (Author m))\n  }\n  deriving (Generic, GQLType)\n\ninstance Monad m => ResolveNamed m (Query (NamedResolverT m)) where\n  type Dep (Query (NamedResolverT m)) = ()\n  resolveNamed () =\n    pure\n      Query\n        { authors = resolve getAuthorIds,\n          authorById = \\(Arg uid) -> resolve (pure (Just uid))\n        }\n\nauthorsApp :: App () IO\nauthorsApp =\n  deriveApp\n    (NamedResolvers :: NamedResolvers IO () Query Undefined Undefined)'),"\n        "),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"App.hs")),Object(r.b)("deckgo-highlight-code",{language:"haskell",terminal:"carbon",theme:"one-dark","line-numbers":"true"},"\n          ",Object(r.b)("code",{parentName:"deckgo-highlight-code",slot:"code"},"app :: App () IO\napp = authorsApp <> postsApp"),"\n        "),Object(r.b)("p",null,"since the both ",Object(r.b)("inlineCode",{parentName:"p"},"Post")," type definitions have same dependency ",Object(r.b)("inlineCode",{parentName:"p"},"ID"),",\nthe interpreter safelly merge this two apps where type\n",Object(r.b)("inlineCode",{parentName:"p"},"Post")," will be extended with new field ",Object(r.b)("inlineCode",{parentName:"p"},"author"),"."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-named-resolvers-mdx-6c2b9e0a80d25babdf2a.js.map